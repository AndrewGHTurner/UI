//SFML .dlls needed for this to work
#include <SFML/Graphics.hpp>
#include <SFML/Graphics/Font.hpp>
#include <iostream>
#include <vector>
#include <fstream>
#include <memory>
using namespace std;
using namespace sf;

class EText {
private:
	Text textSfml;
	string text;
public:

	RenderTexture renderTesture;

	EText(Font& font, string initialText) : textSfml(font, initialText) {
		text = initialText;
		textSfml.setFillColor(sf::Color::Red);
	}

	void draw(RenderWindow& window)
	{
		window.draw(textSfml);
	}
	void setPosition(Vector2f position)
	{
		position.x += 10;
		textSfml.setPosition(position);
	}
	void setSize(Vector2f size)
	{

	}
	void setText(string newText, sf::Font& font)
	{
		textSfml.setString(newText);
		text = newText;
	}
};

class Clickable {
protected:
	void* param = nullptr;
	void (*onClick)(void*);
public:
	Clickable(void (*onClickFunk)(void*))
	{
		cout << onClickFunk << endl;
		onClick = onClickFunk;
		cout << "onclick " << onClick << endl;
	}
	inline void click()
	{
		cout << onClick << " " << param << endl;;
		onClick(param);
	}
	void setParam(void* p)
	{
		param = p;
	}
};


//So I think I have two options... either each widget needs to hold references 
//to click and hover etc functions(most of which will be empty) or each widget 
//will have an ID and an external data structure will need to be queried for the 
//click hover etc functions. 

//go with option one ... just not worth over optimising atm ... USE INHERITANCE AND VIRTUAL FUNCTIOS ... would need silly classes like hoverable button, hoverable clickable button etc

//or option 2....
//behaviour manager
//holds a list of free IDs which which will be vector indices for hover click functions etc. JUST USE A DAMMED STD::UNORDERED_MAP
//each box would just need to hold its ID
//an element only gets an ID if it uses that thing eg hover


//box on the screen
class Box {
protected:
	Vector2f origin;//top right
	Vector2f antiOrigin;//bottom left
	Vector2f size;
public:
	Box(Box* parent, Vector2f origin, Vector2f siz) : container(parent) {
		setOrigin(origin);
		setSize(siz);
	}
	bool isLeaf = true;
	std::optional<std::unique_ptr<Clickable>> clicker;
	bool contentChanged = false;
	bool containsText = false;//sfml text has its own draw calls... would like to just use main vertex array but too complicated for now
	Box* container;
	short numTexts = 0;
	void notifyTextChanged(bool added)//bool for if text object was added or not
	{

		if (added)
		{
			numTexts += 1;
			containsText = true;
		}
		else
		{
			numTexts -= 1;
			if (numTexts == 0)
			{
				containsText = false;
			}
		}
		if (container) {
			container->notifyTextChanged(added);
		}
	}
	void setOrigin(Vector2f origin)
	{
		this->origin = origin;
		antiOrigin = Vector2f(origin.x + size.x, origin.y + size.y);
		notifyChange();
	}
	void setSize(Vector2f siz)
	{
		size = siz;
		antiOrigin = Vector2f(origin.x + size.x, origin.y + size.y);
		notifyChange();
	}
	bool isPointWithin(Vector2i point)
	{
		if (point.x > origin.x && point.y > origin.y)
		{
			if (point.x < antiOrigin.x && point.y < antiOrigin.y)
			{
				return true;
			}
		}
		return false;
	}
	//notify any changes in the positions of the verticies in the vertex array
	void notifyChange()
	{
		contentChanged = true;
		if (container)
		{
			container->notifyChange();
		}
	}
};

//this is a box that draws itself as UI ... 
class Leaf : public Box
{
protected:
	VertexArray& vertices;
	int index;

public:
	std::optional<std::unique_ptr<EText>> text;
	void updateVerticesPosition()
	{
		//first triangle
		vertices[index].position = origin;
		vertices[index + 1].position = Vector2f(origin.x, antiOrigin.y);
		vertices[index + 2].position = Vector2f(antiOrigin.x, origin.y);
		//second triangle
		vertices[index + 3].position = Vector2f(antiOrigin.x, origin.y);
		vertices[index + 4].position = Vector2f(origin.x, antiOrigin.y);
		vertices[index + 5].position = Vector2f(antiOrigin.x, antiOrigin.y);


		contentChanged = false;
	}
	void r()
	{
		if (text)
		{
			(*text)->setPosition(origin);
			(*text)->setSize(this->size);
		}
	}
	Leaf(Vector2f origin, Vector2f siz, VertexArray& verts, int ind, Box* container) : vertices(verts), index(ind), Box(container, origin, siz)
	{
		isLeaf = true;
	}
};

class Button : public Leaf {
private:
	void* onLeftDownParam = nullptr;
	void (*onLeftDown)(void*);
public:
	Button(Font& font, VertexArray& verts, int ind, Vector2f origin, Vector2f siz, void (*clickFunction)(void*), Box* container, string initialText = "")
		: Leaf(origin, siz, verts, ind, container)
	{
		clicker = std::make_unique<Clickable>(clickFunction);
		if (initialText != "")
		{

			text = make_unique<EText>(font, initialText);
			(*text).get()->setPosition(origin);
			(*text).get()->setSize(siz);
			notifyTextChanged(true);
		}
		updateVerticesPosition();
	}
	Button(VertexArray& verts, int ind, Vector2f origin, Vector2f siz, void (*clickFunction)(void*), Box* container)
		: Leaf(origin, siz, verts, ind, container)
	{
		clicker = std::make_unique<Clickable>(clickFunction);
		updateVerticesPosition();
	}
	Button(const Button&) = delete;  // Prevent copying



	void setColor(Color c)
	{
		vertices[index].color = c;
		vertices[index + 1].color = c;
		vertices[index + 2].color = c;
		vertices[index + 3].color = c;
		vertices[index + 4].color = c;
		vertices[index + 5].color = c;
	}

};

class Branch : public Box {
public:
	Branch(Box* container, Vector2f origin, Vector2f siz) : Box(container, origin, siz)
	{
		isLeaf = false;
	}
	vector<Box*> children;
	void add(Box* child)
	{
		children.push_back(child);
		notifyChange();
	}
	virtual void calcPositions() {};
	void drawText(RenderWindow& window)
	{
		for (Box* child : children)
		{

			if (child->containsText)
			{
				if (child->isLeaf)
				{
					if (static_cast<Leaf*>(child)->text)
					{
						(*static_cast<Leaf*>(child)->text).get()->draw(window);
					}

				}
				else
				{
					static_cast<Branch*>(child)->drawText(window);
				}
			}
		}
	}
	void updateChildren()
	{
		calcPositions();
		for (Box* child : children)
		{
			if (child->contentChanged)
			{
				if (child->isLeaf)
				{
					static_cast<Leaf*>(child)->updateVerticesPosition();
					if (static_cast<Leaf*>(child)->text)
					{
						(*static_cast<Leaf*>(child)).r();
					}
				}
				else
				{
					static_cast<Branch*>(child)->updateChildren();
				}
			}
		}
		contentChanged = false;
	}
	void leftDown(Vector2i pos)
	{
		for (Box* child : children)
		{
			if (child->isPointWithin(pos))
			{
				if (child->isLeaf)
				{

				}
			}
		}
	}
	void clickedAt(Vector2i pos)
	{
		for (Box* child : children)
		{
			if (child->isPointWithin(pos))
			{
				if (child->isLeaf)
				{
					if (child->clicker)
					{
						(*child->clicker)->click();
						//	cout << "MMM";
							//static_cast<ClickableLeaf*>(child)->clickedAt(pos);
					}
				}
				else
				{
					//may wish to add support for clickable branches????
					cout << "MFFMM";

					static_cast<Branch*>(child)->clickedAt(pos);
				}
				break;//no need to search the rest of the tree
			}
		}
	}
};

class HorizontalSpacedBar : public Branch {
private:
	//	vector<Button*> buttons;
public:
	HorizontalSpacedBar(Vector2f origin, Vector2f siz, Box* container) : Branch(container, origin, siz) {
		//buttons = vector<Button*>();
		//size = siz;
		//this->origin = origin;
		//antiOrigin = Vector2f(origin.x + siz.x, origin.y + siz.y);

	}

	void calcPositions() override
	{
		float buttonWidth = size.x / children.size();
		float buttonHeight = antiOrigin.y - origin.y;
		Vector2f buttonSize(buttonWidth, buttonHeight);
		int leftX = origin.x;
		for (Box* box : children)
		{
			Vector2f buttonOrigin(leftX, origin.y);
			box->setOrigin(buttonOrigin);
			box->setSize(buttonSize);


			leftX += buttonWidth;
		}
	}
};

class VertexArrayManager
{
private:
	sf::RenderStates states;
	Texture atlas;

protected:
	//vector<Button*> buttonVector;
	VertexArray vertices;
	int vertexCount = 0;
	int addVertices(int numToAdd) {
		vertexCount += numToAdd * 2;
		vertices.resize(vertexCount);
		return vertexCount - numToAdd;
	}
public:
	VertexArrayManager() {
		vertices = VertexArray(sf::PrimitiveType::Triangles, 0);
	}

};

class UI : public Branch, VertexArrayManager {
private:
	sf::Font font;
public:
	UI() : Branch(nullptr, Vector2f(0, 0), Vector2f(300, 300)) {
		if (!font.openFromFile("Terminal.ttf")) {
			cout << "font could not be loaded" << endl;
		}
	}
	void draw(RenderWindow& const window)
	{
		bool t = contentChanged;
		if (contentChanged)
		{
			updateChildren();
		}
		window.draw(vertices);
		//draw text
		if (containsText)
		{
			drawText(window);
		}



	}
	//origin - top right courner of the button
	//size - length of the button in the x and y dimensions
	Button* addButton(Vector2f origin, Vector2f size, void (*onClick)(void*), Box* container)
	{
		int startIndex = addVertices(6);
		Button* newButton = new Button(vertices, startIndex, origin, size, onClick, container);
		return newButton;
	}
	Button* addButton(Vector2f origin, Vector2f size, void (*onClick)(void*), Box* container, string initialText)
	{
		int startIndex = addVertices(6);
		Button* newButton = new Button(font, vertices, startIndex, origin, size, onClick, container, initialText);
		return newButton;
	}
};

void g(void*) {
	cout << "clicked";
}

int height = 10;
int width = 10;
void incrementSize(void* param) {
	cout << "clicked 2" << endl;
	//Button* b = (Button*)param;
	//height += 10;
	//width += 10;
	//b->setSize(Vector2f(width, height));
}

int main()
{
	RenderWindow window(VideoMode({ 300, 300 }), "Mandelbrot");
	CircleShape shape(100.f);
	shape.setFillColor(Color::Green);
	cout << incrementSize << endl;
	UI ui = UI();

	Vector2f UIOrigin(0, 0);
	Vector2f UISize(300, 300);
	ui.setOrigin(UIOrigin);
	ui.setSize(UISize);


	Vector2f o(30, 30);
	Vector2f s(200, 40);
	HorizontalSpacedBar h(o, s, &ui);

	Vector2f buttonOrigin = Vector2f(30, 30);
	Vector2f buttonSize = Vector2f(40, 30);
	Button* gh = ui.addButton(buttonOrigin, buttonSize, g, &h);
	h.add(gh);
	gh->setColor(Color::Red);

	Vector2f buttonOrigin2 = Vector2f(90, 90);
	Vector2f buttonSize2 = Vector2f(40, 30);
	Button* j = ui.addButton(buttonOrigin2, buttonSize2, incrementSize, &h, "hello");
	h.add(j);
	//j->setParam(j);
	j->r();
	ui.add(&h);

	while (window.isOpen())
	{
		while (std::optional event = window.pollEvent())
		{
			if (event->is<Event::Closed>())
			{
				window.close();
			}
			if (event->getIf<Event::MouseButtonPressed>())
			{
				ui.clickedAt(Mouse::getPosition(window));
			}
		}
		window.clear();
		window.draw(shape);
		ui.draw(window);
		window.display();
	}
	return 0;
}